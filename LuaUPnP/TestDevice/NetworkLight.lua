-----------------------------------------------------------------
--  Test module, initialize here, main test function below
-----------------------------------------------------------------

local copas = require('copas.timer')        -- load Copas socket scheduler
local eventer = require('copas.eventer')
local dss = require('dss')      -- load darksidesync module
local upnp = require("LuaUPnP")

-- Link Copas to DSS;
-- the darksidesync lib has a Lua side piece of code that listens to the UDP signal whenever
-- a background lib has delivered something.
-- It provides a socket we need to listen on, and a callback that needs to be called when
-- the socket is ready to read data. All we need to do is add them to our socket scheduler.
-- We're using Copas as a socket scheduler, so add the darksidesync socket and the handler in a
-- Copas way to the scheduler
copas.addserver(dss.getsocket(), function(skt)
        skt = copas.wrap(skt)
        local hdlr = dss.gethandler()
        while true do
            hdlr(skt)
        end
    end)

local errf = function(msg)
	print (debug.traceback(msg or "Stacktrace:"))
    copas.exitloop()
end


-- Table containg all UPnP events generated by the UPnP lib
local UPnPEvents = {
-- SSDP stuff
	UPNP_DISCOVERY_ADVERTISEMENT_ALIVE = {
		type = "SSDP",
		},
	UPNP_DISCOVERY_SEARCH_RESULT = {
		type = "SSDP",
		},
	UPNP_DISCOVERY_SEARCH_TIMEOUT = {
		type = "SSDP",
		},
	UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE = {
		type = "SSDP",
		},
-- SOAP Stuff
	UPNP_CONTROL_ACTION_COMPLETE = {
		type = "SOAP",
		},
	UPNP_CONTROL_GET_VAR_COMPLETE = {
		type = "SOAP",
		},
-- GENA Stuff
	UPNP_EVENT_RECEIVED = {
		type = "GENA",
		},
	UPNP_EVENT_SUBSCRIBE_COMPLETE = {
		type = "GENA",
		},
	UPNP_EVENT_UNSUBSCRIBE_COMPLETE = {
		type = "GENA",
		},
	UPNP_EVENT_RENEWAL_COMPLETE = {
		type = "GENA",
		},
	UPNP_EVENT_AUTORENEWAL_FAILED = {
		type = "GENA",
		},
	UPNP_EVENT_SUBSCRIPTION_EXPIRED = {
		type = "GENA",
		},
-- Device events
	UPNP_EVENT_SUBSCRIPTION_REQUEST = {
		type = "DEVICE",
		},
	UPNP_CONTROL_GET_VAR_REQUEST = {
		type = "DEVICE",
		},
	UPNP_CONTROL_ACTION_REQUEST = {
		type = "DEVICE",
		},
}
-- Add a 'name' element to each event
for k,v in pairs(UPnPEvents) do
    v.name = k
end

-- Eventhandlers per event type
local EventTypeHandlers = {
    DEVICE = function(event, wt)
    end,
    SOAP = function(event, wt)
    end,
    SSDP = function(event, wt)
        -- for now pass on to SOAP handler
        EventTypeHandlers.SOAP(event, wt)
    end,
    GENA = function(event, wt)
        -- for now pass on to SOAP handler
        EventTypeHandlers.SOAP(event, wt)
    end,
}

-- Callback function, executed whenever a UPnP event arrives
-- wt = waitingthread object, on which 'setresult' must be called
-- event = table with event parameters
local UPnPCallback = function (wt, event)
    local err
    if type(wt) ~= "userdata" then
        err = event
        event = wt
        wt = nil
    end
    if event then
        -- we've got an event to handle
        local et = event.Event
        if EventTypeHandlers[et] then
            -- execute handler for the received event type
            EventTypeHandlers[et](event, wt);
        end
    else
        -- an error occured
        print ("LuaUPnP error:")
        print(err)
        print()
    end
end

-----------------------------------------------------------------
--  Test functions, put main code here
-- if a different interval to next test is required, return interval in seconds
-----------------------------------------------------------------
local device        -- UPnP device handle
local webroot = "./web"
local baseurl
local upnpcb = function(wt, event) -- wt = waiting thread
    local err
    if type(wt) ~= "userdata" then
        err = event
        event = wt
        wt = nil
    end
    if event then
        print ("Received event:")
        if wt then print("thread: ", wt) end
        table.print(event)
        print()
        if event.Event == "UPNP_EVENT_SUBSCRIPTION_REQUEST" then
            -- let's accept the subscription
            wt:setresult(device, { ["Status"] = 1 })
        elseif event.Event == "UPNP_CONTROL_ACTION_REQUEST" then
            -- print action xml
            print(upnp.ixml.PrintDocument(event.ActionRequest))
            print("ActionResponse");
            local a, b = wt:setresult({[1] = "RetLoadLevelStatus"}, {[1] = 50})
            if a then
                print(upnp.ixml.PrintDocument(a))
            else
                print(a, b)
            end
        end
    else
        -- an error occured
        print ("LuaUPnP error:")
        print(err)
        print()
    end
end

local testlist = {
    function()
        print("starting UPnP")
        upnp.Init(upnpcb)
        baseurl = "http://" .. upnp.GetServerIpAddress() .. ":" .. upnp.GetServerPort() .. "/";
        print ("BaseURL:", baseurl)
    end,

    function()
        print("Setting webserver root")
        print (upnp.web.SetRootDir(webroot))
    end,

    function()
        print("Registering device")
        local result = { upnp.RegisterRootDevice(baseurl .. "DimmableLight_dcp.xml") }
        device = result[1]
        table.print(result);
        return
    end,

    function()
        print("Advertising device")
        local result = { device:SendAdvertisement(100) }
        table.print(result);
        return 600
    end,

    function()
        print("Unregistering device")
        local result = { device:UnRegisterRootDevice() }
        table.print(result);
    end,

    function()
        print("stopping UPnP")
        upnp.Finish()
    end,

}


-----------------------------------------------------------------
--  Generic test functionality to start and trace errors
-----------------------------------------------------------------

local timer
local testcount = 1
local testinterval = 1/2      -- seconds
-- test function to run tests in a row
local test = function()

    if testlist[testcount] then
        -- run next test
        print ("=========== starting test " .. testcount .. " ===========")
        local success, int = xpcall(testlist[testcount], errf)
        if success then
            int = int or testinterval
        else
            int = testinterval
        end
        timer:arm(int)
        testcount = testcount + 1
        if int ~= testinterval then
            print("(next test starts in " .. tostring(int) .. " seconds)")
        end
    else
        -- we're done, exit
        print ("=========== tests completed ===========")
        timer:cancel()
        copas.exitloop()
    end

end


wait ("Press enter to start...")

-- create timer for test function
timer = copas.newtimer(nil, test, nil, true, nil)
timer:arm(0)    -- run first test immediately

copas.loop()

--wait ("Press enter to exit...")

